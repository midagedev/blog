<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>애매한중년개발자 blog (Page 2)</title>
    <link rel="stylesheet" href="/assets/built/screen.css?v=d141b747f3">

    <link rel="canonical" href="https://blog.midagedev.com/page/2/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="prev" href="https://blog.midagedev.com/">
    <meta name="generator" content="Ghost 5.54">
    <link rel="alternate" type="application/rss+xml" title="애매한중년개발자 blog" href="https://blog.midagedev.com/rss/">
    
    <script defer src="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/sodo-search.min.js" data-key="a3bcd90eef780e8e2967d52431" data-styles="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/main.css" data-sodo-search="https://blog.midagedev.com/" crossorigin="anonymous"></script>
    
    <link href="https://blog.midagedev.com/webmentions/receive/" rel="webmention">
    <script defer src="/public/cards.min.js?v=d141b747f3"></script><style>:root {--ghost-accent-color: #28821c;}</style>
    <link rel="stylesheet" type="text/css" href="/public/cards.min.css?v=d141b747f3">
</head>

<body class="paged is-head-stacked has-serif-body">
<div class="gh-site">

    <header id="gh-head" class="gh-head gh-outer">
        <div class="gh-head-inner gh-inner">
            <div class="gh-head-brand">
                <div class="gh-head-brand-wrapper">
                    
                    <a class="gh-head-logo" href="https://blog.midagedev.com">
                            애매한중년개발자 blog
                    </a>
                    
                </div>
                <button class="gh-search gh-icon-btn" aria-label="Search this site" data-ghost-search><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                <button class="gh-burger"></button>
            </div>

            <nav class="gh-head-menu">
                <ul class="nav">
    <li class="nav-home"><a href="https://blog.midagedev.com/">HOME</a></li>
    <li class="nav-about"><a href="https://blog.midagedev.com/about/">ABOUT</a></li>
</ul>

                        <button class="gh-search gh-icon-btn" aria-label="Search this site" data-ghost-search><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
            </nav>

            <div class="gh-head-actions">
            </div>
        </div>
    </header>

    
<main class="gh-main gh-outer">
    <div class="gh-inner">

        <section class="gh-pagehead">
            <h1 class="gh-pagehead-title">Latest</h1>
        </section>

        <div class="gh-topic gh-topic-grid">
            <div class="gh-topic-content gh-feed">
                            <article class="gh-card post no-image large">
    <a class="gh-card-link" href="/ts-pattern/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">ts-pattern</h3>
            </header>

                    <div class="gh-card-excerpt">ts-pattern 라이브러리는 TypeScript를 위한 전체적인 패턴 매칭 라이브러리입니다. 이 라이브러리는 패턴 매칭의 강력함과 타입 안정성을 결합하여 TypeScript에서 패턴 매칭을 쉽게 사용할 수 있게 해줍니다.


아래는 ts-pattern를 사용하는 몇 가지 예제입니다. 사용하기 전에 라이브러리를 설치해야 합니다.



npm install ts-pattern --save



 1. 기본적인 패턴 매칭



import { match } from 'ts-pattern';

const x = 10;</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-08-13">2023년 8월 13일</time>
            </footer>
        </div>
    </a>
</article>                            <article class="gh-card post no-image">
    <a class="gh-card-link" href="/python-pattern-matching/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">python 패턴매칭</h3>
            </header>

                    <div class="gh-card-excerpt">파이썬 3.10부터는 패턴 매칭을 위한 구조가 추가되었습니다. 패턴 매칭은 주로 switch/case 문을 대체하려는 의도로 도입되었으며, 파이썬에서는 match와 case 키워드를 사용하여 이를 구현합니다.



기본 사용법


간단한 match 예제를 보겠습니다:



x = 10

match x:
    case 10:
        print("x는 10입니다.")
    case 20:
        print("x는 20입니다.")
    case _:
        print("x는 알 수 없는</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-08-13">2023년 8월 13일</time>
            </footer>
        </div>
    </a>
</article>                            <article class="gh-card post no-image">
    <a class="gh-card-link" href="/python-classmethod-staticmethod/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">python 클래스의 classmethod와 staticmethod</h3>
            </header>

                    <div class="gh-card-excerpt">이 데코레이터들은 메서드의 동작 방식을 변경하여, 인스턴스 메서드가 아닌 클래스 레벨에서 동작하는 메서드를 정의할 수 있게 해줍니다.


 1. @classmethod :


 * 첫 번째 인자로 클래스 자체(cls)를 받습니다. 이를 통해 클래스 변수에 접근하거나 클래스 메서드를 호출할 수 있습니다.
 * 인스턴스를 생성하지 않고도 클래스 레벨에서 메서드를 호출할 수 있습니다.
 * Django 모델에서는, 특정 조건에</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-08-13">2023년 8월 13일</time>
            </footer>
        </div>
    </a>
</article>                            <article class="gh-card post no-image">
    <a class="gh-card-link" href="/python-dataclass/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">python의 dataclass</h3>
            </header>

                    <div class="gh-card-excerpt">데이터클래스에 대해 알려줘


dataclass는 Python 3.7부터 표준 라이브러리인 dataclasses 모듈에 추가된 데코레이터입니다. 기본적으로 dataclass는 클래스 내의 필드들을 기반으로 초기화, 비교, 출력 메서드 등을 자동으로 생성해 줍니다. dataclass를 사용하면 반복적인 코드를 작성하지 않고도 깔끔하게 데이터를 저장하고 사용하는 클래스를 작성할 수 있습니다.


예제를 통해 이해해봅시다:



from dataclasses import dataclass

@dataclass
class</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-08-13">2023년 8월 13일</time>
            </footer>
        </div>
    </a>
</article>                            <article class="gh-card post no-image">
    <a class="gh-card-link" href="/domain-driven-design/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">Domain-Driven Design 도메인 주도 개발</h3>
            </header>

                    <div class="gh-card-excerpt">DDD에 대해 ChatGPT대화한 내용입니다.



레이어에 대해


도메인 주도 개발(Domain-Driven Design, DDD)은 복잡한 애플리케이션을 구축할 때 사용되는 아키텍처와 설계 접근 방식입니다. DDD는 주로 네 가지 주요 레이어로 구성됩니다: Presentation, Application, Domain, Infrastructure.


 1. Presentation Layer (프레젠테이션 레이어):


 * 사용자의 요청을 처리하고 응답을 제공하는 레이어.
 * 사용자 인터페이스(UI)와 관련된 코드</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-08-13">2023년 8월 13일</time>
            </footer>
        </div>
    </a>
</article>                            <article class="gh-card post no-image">
    <a class="gh-card-link" href="/stop-being-a-junior/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">Stop Being a Junior 주니어 개발자</h3>
            </header>

                    <div class="gh-card-excerpt">Stop Being a JuniorSome advise for people who still consider themselves junior developers

위 블로그의 내용을 요약합니다.

"주니어 개발자입니까?"라는 질문에 대한 답변을 시작으로, Kent C. Dodds는 개발자가 자신을 "주니어"로 느끼는 이유와 이를 벗어나는 방법에 대해 논의합니다.


 1. 주니어의 정의 : 많은 사람들이 자신을 "주니어"라고 부르며, 이는 직함, 작업의</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-08-10">2023년 8월 10일</time>
            </footer>
        </div>
    </a>
</article>                            <article class="gh-card post no-image">
    <a class="gh-card-link" href="/why-functional-programming-matters/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">Why Functional Programming Matters 함수형 프로그래밍</h3>
            </header>

                    <div class="gh-card-excerpt">https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf

위 글에 대한 요약


1. 서론 (Introduction) [Page 1]

함수형 프로그래밍은 함수의 적용을 기본 연산으로 사용하며, 주요 프로그램도 입력을 인수로 받고 출력을 결과로 제공하는 함수로 작성됩니다. 이 접근 방식은 소프트웨어의 복잡성을 줄이고 모듈화를 촉진하며, 디버깅을 쉽게 만듭니다. 또한,</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-08-04">2023년 8월 4일</time>
            </footer>
        </div>
    </a>
</article>                    <article class="gh-card post no-image">
    <a class="gh-card-link" href="/more-what-less-how/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">More What, Less How</h3>
            </header>

                    <div class="gh-card-excerpt">More What, Less HowSynthetic -> analytic skillsSoftware Design: Tidy First?Kent Beck

kent back의 AI에 대한 2023년 4월 23일의 글을  chatgpt를 통해 요약한 내용

해당 글은 "More What, Less How"라는 제목으로, 프로그래밍 언어와 기술의 진화에 대한 이야기를 담고 있습니다.

1975년, 저자의 아버지는 어셈블리 언어 프로그래머로서, C와 같은 고급 언어에</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-07-19">2023년 7월 19일</time>
            </footer>
        </div>
    </a>
</article>                    <article class="gh-card post no-image">
    <a class="gh-card-link" href="/arima-vs-lstm/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">시계열 예측모델 ARIMA와 LSTM</h3>
            </header>

                    <div class="gh-card-excerpt">ARIMA (Autoregressive Integrated Moving Average)와 LSTM (Long Short-Term Memory)은 두 가지 주요 시계열 예측 알고리즘입니다. 그러나 이 두 알고리즘은 사용 방법, 구조, 그리고 동작 방식에서 꽤 많은 차이점이 있습니다.

 1. 모델 타입: ARIMA는 통계 기반의 선형 모델입니다. 시계열의 패턴을 인식하고 이를 사용하여 미래 값을 예측하는데, 자기 상관성이 있는</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-07-18">2023년 7월 18일</time>
            </footer>
        </div>
    </a>
</article>                    <article class="gh-card post no-image">
    <a class="gh-card-link" href="/django-preform-create/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">django viewset에서 create와 perform_create의 차이</h3>
            </header>

                    <div class="gh-card-excerpt">Django REST Framework에서 ViewSet은 API 로직을 구성하는 방법을 제공합니다. ViewSet에서 사용하는 주요 메서드 중 두 가지인 create와 perform_create에는 명확한 차이가 있습니다.

 * create는 POST 요청이 들어왔을 때 데이터를 생성하는 뷰의 로직입니다. request 객체를 받아 해당 데이터를 이용해 새로운 인스턴스를 생성하고, 응답을 리턴하는 로직을 포함합니다. create 메서드는 API 요청에 대한 전체적인</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-07-18">2023년 7월 18일</time>
            </footer>
        </div>
    </a>
</article>                    <article class="gh-card post no-image">
    <a class="gh-card-link" href="/commonjs-is-not-going-away/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">commonjs is not going away</h3>
            </header>

                    <div class="gh-card-excerpt">앞서 deno의 글과는 상반된 입장의 bun의 블로그에 올라온 글 요약 from chatgpt

"CommonJS is not going away"라는 제목의 기사는 CommonJS가 여전히 유지될 것이며, 이는 괜찮은 일이라고 말하고 있습니다. CommonJS는 2009년에 개발되어 Node.js에 의해 널리 사용되는 모듈 형식입니다. 반면 ECMAScript 모듈(ES 모듈)은 2015년에 도입되었습니다. ES 모듈은 브라우저에서</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-07-15">2023년 7월 15일</time>
            </footer>
        </div>
    </a>
</article>                    <article class="gh-card post no-image">
    <a class="gh-card-link" href="/commonjs-is-hurting-javascript/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">commonjs is hurting javascript</h3>
            </header>

                    <div class="gh-card-excerpt">deno에서 작성한 commonjs가 자바스크립트 생태계에 악영향을 준다는 내용의 블로그 글에 대한 요약 from chatgpt

"CommonJS is hurting JavaScript"라는 제목의 기사는 JavaScript의 발전을 저해하는 요인으로 CommonJS 모듈 시스템을 지목하고 있습니다. 요약하면 다음과 같습니다.

 * JavaScript는 웹 개발에서 널리 사용되는 언어로, 그러나 과거의 유산인 CommonJS로 인해 발전이 저해되고 있다.
 * CommonJS는 약 15년</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-07-15">2023년 7월 15일</time>
            </footer>
        </div>
    </a>
</article>                    <article class="gh-card post no-image">
    <a class="gh-card-link" href="/ghost-cloudflare-pages-blog-deploy/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">ghost + cloudflare pages로 블로그 셋팅</h3>
            </header>

                    <div class="gh-card-excerpt">cloudflare의 기능을 이용해 한시간만에 도메인+호스팅+배포+어낼리틱스 싹 붙인 충격적인 경험


시작점

chatgpt에서 주고받는 질문 답변들이 정확도가 조금 떨어지더라도 나와 비슷한 궁금증을 가진 분들에게 도움이 될 수 있겠다 싶어서 이 내용을 공유할 블로그를 만들어봐야겠다는 생각이 들었음


무지성 도메인 구입

chatgpt에게 도메인명을 추천받았음, midagedev라는 키워드가 구글에서 검색되지 않는 것을 확인하고</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-07-15">2023년 7월 15일</time>
            </footer>
        </div>
    </a>
</article>                    <article class="gh-card post no-image">
    <a class="gh-card-link" href="/python-no-gil/">

        <div class="gh-card-wrapper">
            <header class="gh-card-header">
                <h3 class="gh-card-title">python에서 GIL을 사용하지 않는다면</h3>
            </header>

                    <div class="gh-card-excerpt">If PEP 703 is accepted, Meta can commit three engineer-years to no-GIL CPython
아래의 내용은 위 글을 보고 chatgpt와의 대화를 정리한 것입니다.


GIL이란?


Python의 GIL이란 Global Interpreter Lock의 약자로, 한 번에 하나의 스레드만 Python 바이트코드를 실행하도록 제한하는 메커니즘이다.


이는 Python 인터프리터가 멀티스레드 환경에서 동시에 실행되는 스레드 간에 데이터를 안전하게 처리하도록</div>

            <footer class="gh-card-footer">
                <span class="gh-card-author">kim hyeoncheol</span>
                <time class="gh-card-date" datetime="2023-07-14">2023년 7월 14일</time>
            </footer>
        </div>
    </a>
</article>            </div>
        </div>

    </div>
</main>

    <footer class="gh-foot gh-outer">
        <div class="gh-foot-inner gh-inner">

            <nav class="gh-foot-menu">
                
            </nav>

            <div class="gh-copyright">
                    애매한중년개발자 blog © 2023. Powered by <a href="https://ghost.org/" target="_blank" rel="noopener">Ghost</a>
            </div>
        </div>
    </footer>

</div>


<script src="/assets/built/main.min.js?v=d141b747f3"></script>



</body>

</html>
